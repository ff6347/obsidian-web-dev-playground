# Journal Entry: Obsidian Web Dev Playground POC

## Summary

Successfully completed full implementation of Obsidian Web Dev Playground POC using subagent-driven development workflow. All 7 planned tasks implemented with comprehensive testing, documentation, and CI/CD infrastructure.

## Key Decisions

### Architecture Patterns

**Separation of Concerns**

- Extracted distinct responsibilities into focused classes (Extractor, Transformer, Renderer, View)
- Each component has single responsibility and clear interfaces
- Made testing straightforward and code maintainable

**Reactive Settings**

- Initially implemented settings as copy passed to view constructor
- Code review identified issue: settings changes didn't affect existing views
- Refactored to pass plugin reference instead, enabling reactive settings
- Lesson: Always consider settings mutability and view lifecycle

**Type Safety**

- Started with missing type declarations for @babel/standalone and @freecodecamp/loop-protect
- Created custom .d.ts files in src/types/ to satisfy TypeScript strict mode
- Maintained zero `any` types throughout codebase
- Lesson: Type declarations should be added immediately when dependencies lack them

### Build System

**Rolldown over esbuild**

- Followed Fabian's preference from reference repo (obsidian-canvas-context)
- ESM-first with build.js script instead of esbuild CLI
- Stricter tsconfig (nodenext, esnext, noUncheckedIndexedAccess)
- Result: Modern, maintainable build setup aligned with Fabian's standards

**Test Infrastructure**

- Vitest with jsdom for DOM testing
- Covered edge cases (Windows line endings, empty input, malformed data)
- 14/14 tests passing with good coverage of core logic
- Integration tests left for manual testing (Obsidian environment too complex to mock)

## What Worked Well

**Subagent-Driven Development**

- Dispatched fresh subagent for each task (1-7)
- Code review after each task caught issues early
- Immediate fixes prevented compounding problems
- Total efficiency: 7 tasks + fixes + final review in single session

**TDD Approach**

- Write test first, verify failure, implement, verify pass, commit
- Pattern worked perfectly for Tasks 2-4 (Extractor, Transformer, Renderer)
- Caught edge cases early (regex handling, whitespace, error types)

**Reference Repository**

- Having obsidian-canvas-context as reference was invaluable
- Copied proven patterns: build.js, rolldown config, semantic-release setup
- Saved significant discovery time

**Iterative Fixes**

- Code reviews identified 15+ issues across all tasks
- Fixed systematically before moving to next task
- Result: Clean codebase with no critical issues

## Challenges & Solutions

### Challenge: Plugin Re-registration Warning

- **Issue:** CodeTransformer registered Babel plugin in constructor, causing warnings on multiple instances
- **Solution:** Added static flag to register plugin only once
- **Learning:** Singleton pattern essential for global plugin registration

### Challenge: Settings Not Reactive

- **Issue:** Views stored settings copy, didn't reflect changes without restart
- **Solution:** Store plugin reference, access plugin.settings dynamically
- **Learning:** Consider object lifecycle when storing references vs copies

### Challenge: Type Declarations Missing

- **Issue:** @babel/standalone and @freecodecamp/loop-protect lacked type definitions
- **Solution:** Created minimal .d.ts files with only needed signatures
- **Learning:** Don't over-engineer type declarations - minimal coverage sufficient for POC

### Challenge: Test Import Extensions

- **Issue:** Test files used .ts imports instead of .js (ESM requirement)
- **Solution:** Updated all test imports to use .js extensions
- **Learning:** ESM with TypeScript requires .js extensions in imports, even for .ts files

## Technical Insights

**Babel Standalone Bundle Size**

- main.js is 4.6MB (Babel is ~2-3MB of that)
- Acceptable for desktop Obsidian plugin
- Future optimization: Could use lighter TypeScript compiler if needed
- Tradeoff: Bundle size vs infinite loop protection reliability

**Blob URL Management**

- Critical to revoke old URLs before creating new ones
- Prevents memory leaks in long-running Obsidian sessions
- Pattern: Store currentBlobUrl, revoke in onClose() and before updates

**Error Handling Strategy**

- Transformation errors displayed in iframe (visible to user)
- Runtime errors go to DevTools console (developer-focused)
- Future enhancement: Capture console output in preview
- Tradeoff: Simple error display vs feature richness for POC

**Debounced Updates**

- 500ms default strikes good balance between responsiveness and performance
- Configurable via settings (100-2000ms range)
- Save-only mode as alternative for users who prefer explicit control
- Pattern works well for live preview use case

## Patterns to Reuse

**Project Setup**

- mise.toml for tool versions
- pnpm with packageManager field in package.json
- Rolldown with custom build.js script
- Vitest with jsdom environment
- Semantic-release with version-bump.js

**Code Organization**

- ABOUTME comments (2 lines) at top of every file
- src/ for implementation, tests alongside
- docs/structure/ for architecture docs
- docs/plans/ for implementation plans
- docs/journals/ for session notes

**Development Workflow**

- Brainstorming → Plan → Worktree → Subagent-driven implementation → Code review → PR
- TodoWrite for tracking progress (critical - prevents forgetting tasks)
- Code review after each task (catches issues early)
- Final review before completion

**Testing Strategy**

- Unit tests for pure logic (extractor, transformer, renderer)
- Manual tests for Obsidian integration (view, settings)
- Edge case coverage (cross-platform, empty input, errors)
- Test real behavior, not mocks

## User Preferences (Fabian)

**Code Style**

- Kebab-case for filenames (settings.ts, not Settings.ts)
- ESM with .js extensions in imports
- Strict TypeScript, no `any` types
- ABOUTME comments required
- No dates in documentation unless requested

**Tools**

- mise for tool versioning
- pnpm for package management
- Rolldown for bundling
- Vitest for testing
- Node 24

**Git Workflow**

- Frequent commits (atomic, one thing per commit)
- Conventional commits (feat:, fix:, docs:, chore:)
- Fix issues immediately when found
- Use worktrees for feature branches

**Development Process**

- YAGNI principle - simple first, optimize later
- TDD for new features
- Keep it simple for POC, can enhance later
- Real-world usage before optimization

## Next Steps

**For This Project**

1. Manual testing in Obsidian vault
2. Gather real-world usage feedback
3. Consider console output capture (medium priority)
4. Custom templates with &lt;slot/&gt; (future enhancement)
5. Image export functionality (secondary feature)

**General Improvements**

- Document this workflow pattern for future projects
- Consider template project with this setup pre-configured
- Refine subagent-driven development process based on this success

## Metrics

- **Duration:** Single session from brainstorming to PR
- **Tasks Completed:** 7 core tasks + CI/CD setup
- **Commits:** 16 commits (planning through completion)
- **Tests:** 14 tests, 100% passing
- **Code:** 543 lines TypeScript (excluding tests)
- **Issues Found:** 15+ issues caught by code reviews
- **Critical Issues:** 0 remaining

## Conclusion

This was a highly successful POC implementation. The subagent-driven development workflow proved extremely effective - each task was implemented cleanly, reviewed thoroughly, and fixed immediately. The resulting codebase is maintainable, well-tested, and properly documented.

Key success factors:

1. Clear planning upfront (detailed plan document)
2. Systematic execution (one task at a time)
3. Immediate code review and fixes
4. Reference repository for proven patterns
5. Comprehensive testing and documentation

The plugin successfully validates the concept and provides a solid foundation for future enhancements. Ready for real-world usage and feedback gathering.
